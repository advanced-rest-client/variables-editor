<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../../mocha/mocha.js"></script>
    <script src="../../../chai/chai.js"></script>
    <script src="../../../wct-mocha/wct-mocha.js"></script>

  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <variables-editor></variables-editor>
      </template>
    </test-fixture>

    <script type="module">
    import '../variables-editor.js';
    import sinon from '../../../sinon/pkg/sinon-esm.js';
    function setEnvironments(element, value) {
      const selector = element.shadowRoot.querySelector('#envSelector');
      selector.environments = value || [{name: 'test-name'}];
    }

    suite('_dispatch()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      const eName = 'test-event';
      const eDetail = 'test-detail';

      test('Dispatches an event', () => {
        const spy = sinon.spy();
        element.addEventListener(eName, spy);
        element._dispatch(eName);
        assert.isTrue(spy.called);
      });

      test('Returns the event', () => {
        const e = element._dispatch(eName);
        assert.typeOf(e, 'customevent');
      });

      test('Event is cancelable by default', () => {
        const e = element._dispatch(eName);
        assert.isTrue(e.cancelable);
      });

      test('Event is composed', () => {
        const e = element._dispatch(eName);
        if (typeof e.composed !== 'undefined') {
          assert.isTrue(e.composed);
        }
      });

      test('Event bubbles', () => {
        const e = element._dispatch(eName);
        assert.isTrue(e.bubbles);
      });

      test('Event is not cancelable when set', () => {
        const e = element._dispatch(eName, eDetail, false);
        assert.isFalse(e.cancelable);
      });

      test('Event has detail', () => {
        const e = element._dispatch(eName, eDetail);
        assert.equal(e.detail, eDetail);
      });
    });

    suite('_dispatchEnvUpdated()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      const item = 'test-item';

      test('Calls _dispatch()', () => {
        const spy = sinon.spy(element, '_dispatch');
        element._dispatchEnvUpdated(item);
        assert.isTrue(spy.called);
      });

      test('Returns the event', () => {
        const e = element._dispatchEnvUpdated(item);
        assert.typeOf(e, 'customevent');
        assert.equal(e.type, 'environment-updated');
      });

      test('Event has detail with item', () => {
        const e = element._dispatchEnvUpdated(item);
        assert.equal(e.detail.value, item);
      });
    });

    suite('_dispatchEnvDeleted()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      const id = 'test-id';

      test('Calls _dispatch()', () => {
        const spy = sinon.spy(element, '_dispatch');
        element._dispatchEnvDeleted(id);
        assert.isTrue(spy.called);
      });

      test('Returns the event', () => {
        const e = element._dispatchEnvDeleted(id);
        assert.typeOf(e, 'customevent');
        assert.equal(e.type, 'environment-deleted');
      });

      test('Event has detail with the id', () => {
        const e = element._dispatchEnvDeleted(id);
        assert.equal(e.detail.id, id);
      });
    });

    suite('_sendGaEvent()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      const action = 'test-action';

      test('Calls _dispatch()', () => {
        const spy = sinon.spy(element, '_dispatch');
        element._sendGaEvent(action);
        assert.isTrue(spy.called);
      });

      test('Returns the event', () => {
        const e = element._sendGaEvent(action);
        assert.typeOf(e, 'customevent');
        assert.equal(e.type, 'send-analytics');
      });

      test('Event is not cancelable', () => {
        const e = element._sendGaEvent(action);
        assert.isFalse(e.cancelable);
      });

      test('Detail has action', () => {
        const e = element._sendGaEvent(action);
        assert.equal(e.detail.action, action);
      });

      test('Detail has category', () => {
        const e = element._sendGaEvent(action);
        assert.equal(e.detail.category, 'Variables editor');
      });

      test('Detail has type', () => {
        const e = element._sendGaEvent(action);
        assert.equal(e.detail.type, 'event');
      });
    });

    suite('_sendGaError()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      const message = 'test-error';

      test('Calls _dispatch()', () => {
        const spy = sinon.spy(element, '_dispatch');
        element._sendGaError(message);
        assert.isTrue(spy.called);
      });

      test('Returns the event', () => {
        const e = element._sendGaError(message);
        assert.typeOf(e, 'customevent');
        assert.equal(e.type, 'send-analytics');
      });

      test('Event is not cancelable', () => {
        const e = element._sendGaError(message);
        assert.isFalse(e.cancelable);
      });

      test('Detail has description', () => {
        const e = element._sendGaError(message);
        assert.equal(e.detail.description, message);
      });

      test('Detail has category', () => {
        const e = element._sendGaError(message);
        assert.equal(e.detail.type, 'exception');
      });

      test('Detail has fatal', () => {
        const e = element._sendGaError(message);
        assert.isFalse(e.detail.fatal);
      });
    });

    suite('_toast()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      const message = 'test toast';

      test('Opens the toast', () => {
        element._toast(message);
        const node = element.shadowRoot.querySelector('#infoToast');
        assert.isTrue(node.opened);
      });

      test('The toast has text message', () => {
        element._toast(message);
        const node = element.shadowRoot.querySelector('#infoToast');
        assert.equal(node.text, message);
      });
    });

    suite('_processVariables()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined when no argument', () => {
        const result = element._processVariables();
        assert.isUndefined(result);
      });

      test('Returns undefined when no base argument', () => {
        const result = element._processVariables({});
        assert.isUndefined(result);
      });

      test('Returns array of variables', () => {
        const vars = [{'variable': 'v1'}, {'variable': 'v2'}];
        const result = element._processVariables({
          base: vars
        });
        assert.deepEqual(result, vars);
      });

      test('Removes system variables', () => {
        const vars = [{variable: 'v1'}, {variable: 'v2', sysVar: true}];
        const result = element._processVariables({
          base: vars
        });
        assert.deepEqual(result, [{variable: 'v1'}]);
      });
    });

    suite('_computeAllowRemove()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns false if no environment', () => {
        const result = element._computeAllowRemove();
        assert.isFalse(result);
      });

      test('Returns false when environment is default', () => {
        const result = element._computeAllowRemove('default');
        assert.isFalse(result);
      });

      test('Returns true otherwise', () => {
        const result = element._computeAllowRemove('some');
        assert.isTrue(result);
      });
    });

    suite('openAddEnvironmentForm()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('Opens the editor', () => {
        element.openAddEnvironmentForm();
        assert.isTrue(element.envEditorOpened);
      });
    });

    suite('closeAddEnvironmentForm()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        element.openAddEnvironmentForm();
        flush(() => done());
      });

      test('Opens the editor', () => {
        element.closeAddEnvironmentForm();
        assert.isFalse(element.envEditorOpened);
      });
    });

    suite('_findEnvironment()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      const searchEnv = 'test-name';

      test('Returns undefined when no environments on the list', () => {
        const result = element._findEnvironment(searchEnv);
        assert.isUndefined(result);
      });

      test('Returns undefined when environments is empty', () => {
        setEnvironments(element, []);
        const result = element._findEnvironment(searchEnv);
        assert.isUndefined(result);
      });

      test('Returns undefined when no environment on the list', () => {
        setEnvironments(element);
        const result = element._findEnvironment('other');
        assert.isUndefined(result);
      });

      test('Returns item model', () => {
        setEnvironments(element);
        const result = element._findEnvironment(searchEnv);
        assert.typeOf(result, 'object');
      });

      test('Skips empty list items', () => {
        setEnvironments(element, [undefined, {name: 'test-name'}]);
        const result = element._findEnvironment(searchEnv);
        assert.typeOf(result, 'object');
      });
    });

    suite('_validateEnvironmentInput()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('Returns false if no name', () => {
        const result = element._validateEnvironmentInput();
        assert.isFalse(result);
      });

      test('Sets input error message when no name', () => {
        element.$.editorEnvName.errorMessage = 'test';
        element._validateEnvironmentInput();
        assert.equal(element.$.editorEnvName.errorMessage, 'Name is required.');
      });

      test('Returns false when name is "default"', () => {
        const result = element._validateEnvironmentInput('default');
        assert.isFalse(result);
      });

      test('Sets input error message when name is "default"', () => {
        element.$.editorEnvName.errorMessage = 'test';
        element._validateEnvironmentInput('default');
        assert.equal(element.$.editorEnvName.errorMessage, 'This name is reserved. Please, use different name.');
      });

      test('Invalidates input when name is "default"', () => {
        element._validateEnvironmentInput('default');
        assert.isTrue(element.$.editorEnvName.invalid);
      });

      test('Returns false when name already defined', () => {
        setEnvironments(element);
        const result = element._validateEnvironmentInput('test-name');
        assert.isFalse(result);
      });

      test('Sets input error message when name already defined', () => {
        setEnvironments(element);
        element.$.editorEnvName.errorMessage = 'test';
        element._validateEnvironmentInput('test-name');
        assert.equal(element.$.editorEnvName.errorMessage, 'Environment already exists. Please, use different name.');
      });

      test('Invalidates input when name already defined', () => {
        setEnvironments(element);
        element._validateEnvironmentInput('test-name');
        assert.isTrue(element.$.editorEnvName.invalid);
      });

      test('Returns true when pases validation', () => {
        const result = element._validateEnvironmentInput('test-env');
        assert.isTrue(result);
      });
    });

    suite('addVariable()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
        element.environment = 'test-default';
      });

      test('Adds variable to an empty list', () => {
        element.addVariable();
        assert.typeOf(element.variables, 'array');
        assert.lengthOf(element.variables, 1);
      });

      test('Adds variable to existing list', () => {
        element.variables = [{name: 'test'}];
        element.addVariable();
        assert.typeOf(element.variables, 'array');
        assert.lengthOf(element.variables, 2);
      });

      test('Added variable has no name', () => {
        element.addVariable();
        const item = element.variables[0];
        assert.isUndefined(item.variable);
      });

      test('Added variable is not enabled', () => {
        element.addVariable();
        const item = element.variables[0];
        assert.isFalse(item.enabled);
      });

      test('Added variable has environment', () => {
        element.addVariable();
        const item = element.variables[0];
        assert.equal(item.environment, element.environment);
      });
    });

    suite('_removeEmptyVariable()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
        element.variables = [{variable: 'v1'}, {variable: 'v2'}];
      });

      test('Does nothing when index not specified', () => {
        element._removeEmptyVariable({
          model: {
            get: () => null
          }
        });
        assert.lengthOf(element.variables, 2);
      });

      test('Does nothing when index is -1', () => {
        element._removeEmptyVariable({
          model: {
            get: () => -1
          }
        });
        assert.lengthOf(element.variables, 2);
      });

      test('Removes the variable', () => {
        element._removeEmptyVariable({
          model: {
            get: () => 0
          }
        });
        assert.lengthOf(element.variables, 1);
      });
    });

    suite('_openHelp()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      const ev = {
        currentTarget: {
          href: 'http://test-href'
        },
        preventDefault: function() {
          ev.defaultPrevented = true;
        },
        stopPropagation: () => {}
      };

      test('Dispatches "open-external-url"', () => {
        let called = false;
        element.addEventListener('open-external-url', function f(e) {
          element.removeEventListener('open-external-url', f);
          e.preventDefault();
          called = true;
        });
        element._openHelp(ev);
        assert.isTrue(called);
      });

      test('Does not return window when event handled', () => {
        element.addEventListener('open-external-url', function f(e) {
          element.removeEventListener('open-external-url', f);
          e.preventDefault();
        });
        const result = element._openHelp(ev);
        assert.isUndefined(result);
      });

      test('Event has "url" property', () => {
        let value;
        element.addEventListener('open-external-url', function f(e) {
          element.removeEventListener('open-external-url', f);
          e.preventDefault();
          value = e.detail.url;
        });
        const result = element._openHelp(ev);
        assert.isUndefined(result);
        assert.equal(value, 'http://test-href');
      });

      test('Returns window', () => {
        const result = element._openHelp(ev);
        if (result) {
          // Popup blocker may block the window and there's nothing I can do about it
          result.close();
        }
      });
    });

    suite('_addEnvInput()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls _addEnvironment() when key is enter', () => {
        const spy = sinon.spy(element, '_addEnvironment');
        element._addEnvInput({
          key: 'Enter'
        });
        assert.isTrue(spy.called);
      });

      test('Calls _addEnvironment() when keyCode is 13', () => {
        const spy = sinon.spy(element, '_addEnvironment');
        element._addEnvInput({
          keyCode: 13
        });
        assert.isTrue(spy.called);
      });

      test('Does nothing otherwise', () => {
        const spy = sinon.spy(element, '_addEnvironment');
        element._addEnvInput({
          keyCode: 90
        });
        assert.isFalse(spy.called);
      });
    });

    suite('_processEnvSplices()', () => {
      let element;
      const env = 'test-env';
      setup(() => {
        element = fixture('Basic');
        element.environment = 'test-env';
      });

      test('Does nothing when no indexSplices', () => {
        element._processEnvSplices({});
        assert.equal(element.environment, env);
      });

      test('Does nothing when no first index of indexSplices', () => {
        element._processEnvSplices({
          indexSplices: []
        });
        assert.equal(element.environment, env);
      });

      test('Does nothing when addedCount is not 1', () => {
        element._processEnvSplices({
          indexSplices: [{
            addedCount: 0
          }]
        });
        assert.equal(element.environment, env);
      });

      test('Updates environment name', () => {
        element._processEnvSplices({
          indexSplices: [{
            addedCount: 1,
            index: 0,
            object: [{name: 'changed-info'}]
          }]
        });
        assert.equal(element.environment, 'changed-info');
      });
    });

    suite('_addEnvironment()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('Does nothing when fails validation', () => {
        element.$.editorEnvName.value = 'default';
        const spy = sinon.spy(element, '_dispatchEnvUpdated');
        element._addEnvironment();
        assert.isFalse(spy.called);
      });

      test('Throws error when no model', () => {
        element.$.editorEnvName.value = 'test-env1';
        assert.throws(() => {
          element._addEnvironment();
        });
      });

      test('Render toast when no model', () => {
        element.$.editorEnvName.value = 'test-env1';
        try {
          element._addEnvironment();
        } catch (_) {}
        const node = element.shadowRoot.querySelector('#infoToast');
        assert.isTrue(node.opened);
      });

      function cancelEvent(element) {
        element.addEventListener('environment-updated', function f(e) {
          element.removeEventListener('environment-updated', f);
          e.preventDefault();
          e.detail.result = Promise.resolve();
        });
      }

      test('Returns a promise', () => {
        element.$.editorEnvName.value = 'test-env1';
        cancelEvent(element);
        const result = element._addEnvironment();
        assert.typeOf(result.then, 'function');
        return result;
      });

      test('Closes the form', () => {
        element.$.editorEnvName.value = 'test-env1';
        const spy = sinon.spy(element, 'closeAddEnvironmentForm');
        cancelEvent(element);
        return element._addEnvironment()
        .then(() => {
          assert.isTrue(spy.called);
        });
      });

      test('Sends GA event', () => {
        element.$.editorEnvName.value = 'test-env1';
        const spy = sinon.spy(element, '_sendGaEvent');
        cancelEvent(element);
        return element._addEnvironment()
        .then(() => {
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'Add environment');
        });
      });

      test('Clears environment name in the input field', () => {
        element.$.editorEnvName.value = 'test-env1';
        cancelEvent(element);
        return element._addEnvironment()
        .then(() => {
          assert.equal(element.$.editorEnvName.value, '');
        });
      });

      function rejectEvent(element) {
        element.addEventListener('environment-updated', function f(e) {
          element.removeEventListener('environment-updated', f);
          e.preventDefault();
          e.detail.result = Promise.reject(new Error('test'));
        });
      }

      test('Renders toast when save error', () => {
        element.$.editorEnvName.value = 'test-env1';
        rejectEvent(element);
        let thenCalled = false;
        return element._addEnvironment()
        .then(() => {
          thenCalled = true;
        })
        .catch(() => {
          if (thenCalled) {
            throw new Error('Promise should reject.');
          }
          const node = element.shadowRoot.querySelector('#infoToast');
          assert.isTrue(node.opened);
        });
      });

      test('Sends GA exception message', () => {
        element.$.editorEnvName.value = 'test-env1';
        const spy = sinon.spy(element, '_sendGaEvent');
        rejectEvent(element);
        let thenCalled = false;
        return element._addEnvironment()
        .then(() => {
          thenCalled = true;
        })
        .catch(() => {
          if (thenCalled) {
            throw new Error('Promise should reject.');
          }
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'Add environment-test');
        });
      });
    });

    suite('_deleteEnvironment()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('Does nothing when default environment', () => {
        element.environment = 'default';
        const spy = sinon.spy(element, '_dispatchEnvDeleted');
        element._deleteEnvironment();
        assert.isFalse(spy.called);
      });

      test('Rejects the promise when default environment', (done) => {
        element.environment = 'default';
        const result = element._deleteEnvironment();
        result.catch(() => done());
      });

      test('Render toast when default environment', () => {
        element.environment = 'default';
        element._deleteEnvironment();
        const node = element.shadowRoot.querySelector('#infoToast');
        assert.isTrue(node.opened);
      });

      test('Does nothing when model element not found', () => {
        element.environment = 'test-name';
        const spy = sinon.spy(element, '_dispatchEnvDeleted');
        element._deleteEnvironment();
        assert.isFalse(spy.called);
      });

      test('Rejects the promise when model element not found', (done) => {
        element.environment = 'test-name';
        const result = element._deleteEnvironment();
        result.catch(() => done());
      });

      test('Rejects the promise when environment model not found', (done) => {
        element.environment = 'test-name';
        setEnvironments(element);
        const result = element._deleteEnvironment();
        result.catch(() => done());
      });

      test('Render toast when environment model not found', () => {
        element.environment = 'test-name';
        setEnvironments(element);
        element._deleteEnvironment();
        const node = element.shadowRoot.querySelector('#infoToast');
        assert.isTrue(node.opened);
      });

      function cancelEvent(element) {
        element.addEventListener('environment-deleted', function f(e) {
          element.removeEventListener('environment-deleted', f);
          e.preventDefault();
          e.detail.result = Promise.resolve();
        });
      }

      test('Returns a promise', () => {
        element.environment = 'test-name';
        setEnvironments(element);
        cancelEvent(element);
        const result = element._deleteEnvironment();
        assert.typeOf(result.then, 'function');
        return result;
      });

      test('Sends GA event', () => {
        element.environment = 'test-name';
        setEnvironments(element);
        const spy = sinon.spy(element, '_sendGaEvent');
        cancelEvent(element);
        return element._deleteEnvironment()
        .then(() => {
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'Delete environment');
        });
      });

      function rejectEvent(element) {
        element.addEventListener('environment-deleted', function f(e) {
          element.removeEventListener('environment-deleted', f);
          e.preventDefault();
          e.detail.result = Promise.reject(new Error('test'));
        });
      }

      test('Renders toast when save error', () => {
        element.environment = 'test-name';
        setEnvironments(element);
        rejectEvent(element);
        let thenCalled = false;
        return element._deleteEnvironment()
        .then(() => {
          thenCalled = true;
        })
        .catch(() => {
          if (thenCalled) {
            throw new Error('Promise should reject.');
          }
          const node = element.shadowRoot.querySelector('#infoToast');
          assert.isTrue(node.opened);
        });
      });

      test('Sends GA exception message', () => {
        element.environment = 'test-name';
        setEnvironments(element);
        const spy = sinon.spy(element, '_sendGaEvent');
        rejectEvent(element);
        let thenCalled = false;
        return element._deleteEnvironment()
        .then(() => {
          thenCalled = true;
        })
        .catch(() => {
          if (thenCalled) {
            throw new Error('Promise should reject.');
          }
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'Add environment-test');
        });
      });
    });

    suite('_revalidateEnvInput()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('Sets invalid state when invalid', () => {
        element._revalidateEnvInput();
        assert.isTrue(element.$.editorEnvName.invalid);
      });

      test('Sets input error message', () => {
        element._revalidateEnvInput();
        assert.equal(element.$.editorEnvName.errorMessage, 'Name is required.');
      });

      test('Does not change name if valid', () => {
        element.$.editorEnvName.value = 'test';
        element.$.editorEnvName.errorMessage = 'test';
        element._revalidateEnvInput();
        assert.equal(element.$.editorEnvName.errorMessage, 'test');
      });

      test('Does not change name if name already set', () => {
        element.$.editorEnvName.errorMessage = 'Name is required.';
        element._revalidateEnvInput();
        assert.equal(element.$.editorEnvName.errorMessage, 'Name is required.');
      });
    });
    </script>

  </body>
</html>
